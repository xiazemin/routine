[https://swtch.com/libtask/](https://swtch.com/libtask/)

在实现了一个任务函数后，真要让这个函数加入到调度队列中，我

们还需要显式调用taskcreate\(\)函数。

每一个任务需要保存以下这几个关键数据：

```
·任务上下文，用于在切换任务时保持当前任务的运行环境；

·栈

·状态

·该任务所对应的业务函数

·任务的调用参数

·之前和之后的任务
```

这个过程其实就是创建并设置了一个Task对象，然后将该对象添加到alltask列表中，接着将该Task对象的状态设置为就绪，表示该任务可以接受调度器的调度。

逻辑其实很简单，就是循环执行正在等待中的任务，直到执行完所有的任务后退出。

读者可

能会觉得奇怪，这个函数里根本没有调用任务所对应的业务函数的代码，那么那些代码到底是怎

么执行的呢？最关键的是下面这一句调用：

contextswitch\(\)

在任务执行过程中发生任务切换只会因为以下原因之一：

·该任务的业务代码主要要求切换，即主动让出执行权；

·发生了IO，导致执行阻塞。

主动出让执行权通过主动调用taskyield\(\)来完成。在下面的代码中，taskswitch\(\)切换上下文以具体做到任务切换，taskready\(\)函数将一个具体的设置为等待执行状态，tasksyield\(\)则借助其他的函数完成执行权出让：

上面的代码做了这几件事情：

·将正在执行的任务放回到等待队列中，免得永远无法再切换回来；

·将该任务的状态设置为yield;

·进行任务切换

libtask库中的fd.c进行了基于轮询的异步IO封装，并在tcpproxy.c中示范了如何使用异步IO来达成自动出让执行权的效果。

当发生IO事件时，程序会先让其他处于yield状态的任务先执行，待清理掉这些可以执行的任务后，开始调用poll来监听所有处于IO阻塞状态的pollfd，一旦有某些pollfd成功读写，则将对应的任务切换为可调度状态。

**6.通信机制**

我们知道，channel是推荐的goroutine之间的通信方式。而实际上，“通信”这个术语并不太适用。从根本上来说，channel只是一个数据结构，可以被写入数据，也可以被读取数据。所谓的发送数据到channel，或者从channel读取数据，说白了就是对一个数据结构的操作，仅此而已

可以看到channel的基本组成如下：

    ·内存缓存，用于存放元素

    ·发送队列

    ·接受队列

从以下这个channel的创建函数可以看出，分配的内存缓存就紧跟在这个channel结构之后：

